"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[53],{1109:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Development Setup","href":"/dragon-game/docs/dev-setup","docId":"dev-setup"},{"type":"link","label":"Configuration","href":"/dragon-game/docs/configuration","docId":"configuration"},{"type":"link","label":"Project Outline","href":"/dragon-game/docs/project-outline","docId":"project-outline"},{"type":"link","label":"State Outline","href":"/dragon-game/docs/state-outline","docId":"state-outline"},{"type":"link","label":"Docs Development Setup","href":"/dragon-game/docs/docs-setup","docId":"docs-setup"},{"type":"link","label":"Remotes System","href":"/dragon-game/docs/remotes","docId":"remotes"},{"type":"category","label":"UI Components","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Card","href":"/dragon-game/docs/components/card","docId":"components/card"}],"href":"/dragon-game/docs/components/"},{"type":"link","label":"Enums","href":"/dragon-game/docs/enums","docId":"enums"},{"type":"link","label":"Unit Testing","href":"/dragon-game/docs/unit-testing","docId":"unit-testing"},{"type":"link","label":"Editing Assets","href":"/dragon-game/docs/editing-assets","docId":"editing-assets"},{"type":"link","label":"Building the Project","href":"/dragon-game/docs/environment","docId":"environment"}]},"docs":{"components/card":{"id":"components/card","title":"Card","description":"The card component is a standard playing card that can receive input and animate from one position to another.","sidebar":"tutorialSidebar"},"components/components":{"id":"components/components","title":"Components","description":"Client UI is assembled from a catalog of Roact UI components. A component receives props (configuration options) that determine its look and behavior. This category is an index of components and how they can be used.","sidebar":"tutorialSidebar"},"configuration":{"id":"configuration","title":"Configuration","description":"Constants and \\"magic numbers\\" are all combined into a single file located at src/shared/Constants/CONFIG.lua. This makes it easy to adjust the game without having to sift through scripts.","sidebar":"tutorialSidebar"},"dev-setup":{"id":"dev-setup","title":"Development Setup","description":"This project requires a couple of command line tools to convert the source into a Roblox place.","sidebar":"tutorialSidebar"},"docs-setup":{"id":"docs-setup","title":"Docs Development Setup","description":"Documentation is a critical resource for making projects easy to maintain. Dragon Game uses Docusaurus, a static site generator. When writing docs, you can preview them on a local development server.","sidebar":"tutorialSidebar"},"editing-assets":{"id":"editing-assets","title":"Editing Assets","description":"Assets are complex Roblox instances that can\'t be easily represented by a file tree or in the Rojo file. Instead, Remodel is used to extract assets from the Roblox level and put them into the assets folder.","sidebar":"tutorialSidebar"},"enums":{"id":"enums","title":"Enums","description":"Enums are options that can\'t be easily represented by another value type.","sidebar":"tutorialSidebar"},"environment":{"id":"environment","title":"Building the Project","description":"To create a Roblox level to test your changes in, run the following command at the root of the project:","sidebar":"tutorialSidebar"},"project-outline":{"id":"project-outline","title":"Project Outline","description":"This is a brief overview of the various files and folders in the project and the purposes they serve.","sidebar":"tutorialSidebar"},"remotes":{"id":"remotes","title":"Remotes System","description":"This project uses the remotes package, which simplifies the creation and usage of remotes:","sidebar":"tutorialSidebar"},"state-outline":{"id":"state-outline","title":"State Outline","description":"This project uses Rodux, a library for centralizing game state. The store state matches the following structure:","sidebar":"tutorialSidebar"},"unit-testing":{"id":"unit-testing","title":"Unit Testing","description":"As a project grows in complexity it becomes harder to thoroughly test for issues when changes are made. To solve this, test scripts are written that feed modules inputs and checks that the outputs match the expected result. These test scripts can all be run at once to test the entire game automatically.","sidebar":"tutorialSidebar"}}}')}}]);